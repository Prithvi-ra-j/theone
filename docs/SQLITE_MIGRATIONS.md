## SQLite-friendly migrations and developer guide

This document explains the changes made to make Alembic migrations work reliably under SQLite for local development, the small runtime helpers added, and guidance for creating future cross-dialect migrations.

Goals
- Allow developers to run `alembic upgrade head` against a local SQLite DB without hitting Postgres-specific SQL errors.
- Keep production migrations compatible with Postgres while providing safe fallbacks for SQLite.

Key patterns and code added

- Safe wrappers
  - `_safe_add_column(op, table_name, column)` and `_safe_drop_column(op, table_name, column_name)` were added to the large autogenerated migration(s). They:
    - Use SQLAlchemy Inspector to check for table and column existence and skip operations that would be no-ops or cause duplicate column/index errors.
    - Strip Postgres-only `server_default` tokens like `::json` or `now()` when running on SQLite by creating a copy of the Column without server_default for the add operation.

- Batch table alterations for SQLite
  - SQLite can't ALTER COLUMN/TYPE/CONSTRAINT. When editing existing tables, use Alembic's batch mode:

```py
with op.batch_alter_table("my_table", recreate='always') as batch_op:
    batch_op.add_column(sa.Column('new_col', sa.String(), nullable=True))
    batch_op.create_unique_constraint('uq_my_table_col', ['col'])
```

- Dialect-aware types
  - Postgres-only types (JSONB, BYTEA, TIMESTAMP with time zone) are compiled for Postgres but may fail on SQLite. Prefer:
    - Use `sa.Text()` or SQLAlchemy's `sa.JSON()` for JSON-like columns in migrations. For binary data use `sa.LargeBinary()`.
    - When generating migrations from models that use Postgres types, convert them to SQLite-friendly equivalents in the migration file.

Guidance for writing new migrations

1. Prefer small, per-table migrations. Large autogenerated migrations increase the risk of dialect-specific failures.
2. When adding or altering columns, wrap schema changes with `op.batch_alter_table(...)` to support SQLite safely.
3. Avoid including raw Postgres SQL or server_default constructs that use `::` casting. Use SQLAlchemy constructs instead and check dialect in code if needed.
4. Make index and constraint creation idempotent by checking for their existence using Inspector when possible.

CI Recommendations

- This repo includes a GitHub Actions workflow that runs migrations and quick tests against both SQLite and a Postgres service. The workflow lives at `.github/workflows/ci.yml`.

Local developer commands

Run migrations locally against SQLite (fast):

```bash
cd backend
export DATABASE_URL="sqlite:////tmp/theone_local.db"
rm -f /tmp/theone_local.db || true
alembic upgrade head
```

Run migrations against Postgres (recommended before merging changes):

```bash
# run a local Postgres (docker)
docker run --rm --name theone-pg -e POSTGRES_PASSWORD=postgres -e POSTGRES_USER=postgres -e POSTGRES_DB=theone_test -p 5432:5432 -d postgres:15

export DATABASE_URL="postgresql+psycopg2://postgres:postgres@localhost:5432/theone_test"
cd backend
alembic upgrade head
```

Troubleshooting

- If you see "near 'ALTER': syntax error" on SQLite, ensure the migration uses `batch_alter_table` for column/constraint/type changes.
- If you see "unrecognized token ':'" from server_default, remove Postgres-specific casting and provide a neutral server_default or none for SQLite.

Notes

- These changes are intended to make local dev and CI easier. They do not change the intended Postgres schema; always validate on Postgres before deploying to production.

Running tests locally
---------------------
- Use Python 3.11 for running the backend code and tests to match Render and avoid compatibility issues seen with Python 3.12/3.13.
- From the repository root set PYTHONPATH so tests can import the `app` package:

```bash
cd backend
export PYTHONPATH=$(pwd)
python -V  # should show Python 3.11.x
pytest -q -m "not integration"
```

If you don't have Python 3.11 installed locally, use `pyenv`, `asdf`, or run tests inside the provided Docker image.
