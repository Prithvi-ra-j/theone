"""add estimated_minutes to Task and start_time to CalendarEvent

Revision ID: 7102fdaf7caa
Revises: make_career_category_nullable
Create Date: 2025-09-20 20:19:07.559981

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '7102fdaf7caa'
down_revision = 'mn9o0p1q2r3'
branch_labels = None
depends_on = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    # Make op.add_column idempotent/safe for SQLite by skipping columns that already exist.
    # This avoids `duplicate column name` errors when running migrations against DBs that
    # already have some of these columns (common in local/dev environments).
    try:
        _orig_add_column = op.add_column

        def _safe_add_column(*args, **kwargs):
            try:
                bind = op.get_bind()
                inspector = sa.inspect(bind)
                table = args[0]
                column = args[1]
                # If the table doesn't exist yet, skip adding the column here. The table
                # might be created in an earlier/later migration; this avoids 'no such table' errors.
                if table not in inspector.get_table_names():
                    return
                existing = [c['name'] for c in inspector.get_columns(table)]
                # column may be a Column object with .name
                col_name = getattr(column, 'name', None)
                if col_name in existing:
                    return

                # If running on SQLite, sanitize Postgres-specific server_default clauses
                dialect = getattr(bind, 'dialect', None)
                dialect_name = getattr(dialect, 'name', '') if dialect is not None else ''
                if dialect_name == 'sqlite':
                    # Create a copy of the column without server_default (SQLite doesn't accept ::json, ::bytea, etc.)
                    col_type = getattr(column, 'type', None)
                    nullable = getattr(column, 'nullable', True)
                    # Build a new Column with same name/type/nullability but no server_default
                    new_col = sa.Column(col_name, col_type, nullable=nullable)
                    return _orig_add_column(table, new_col)
            except Exception:
                # If anything goes wrong, fall back to original behavior
                pass
            return _orig_add_column(*args, **kwargs)

        op.add_column = _safe_add_column
    except Exception:
        # If we can't patch op.add_column, fall back to original behavior.
        pass

    # Patch op.drop_column to be safe (skip if column or table doesn't exist)
    try:
        _orig_drop_column = op.drop_column

        def _safe_drop_column(table_name, column_name, **kwargs):
            try:
                bind = op.get_bind()
                inspector = sa.inspect(bind)
                if table_name not in inspector.get_table_names():
                    return
                existing = [c['name'] for c in inspector.get_columns(table_name)]
                if column_name not in existing:
                    return
            except Exception:
                # If inspection fails, fall back to original
                pass
            return _orig_drop_column(table_name, column_name, **kwargs)

        op.drop_column = _safe_drop_column
    except Exception:
        pass

    # Achievement table changes were extracted to a separate migration `a1b2c3d4e5f6`.
    # This migration assumes that work is already applied.
    # badge changes moved to cd4e5f6g7h8_split_badge_changes.py
    # calendarevent changes moved to ij7k8l9m0n1_split_calendarevent_changes.py
    # conversation changes moved to ef5g6h7i8j9_split_conversation_changes.py
        # Achievement table changes were extracted to a separate migration `a1b2c3d4e5f6`.
        # This migration assumes that work is already applied.
    # moodlog changes moved to bc1d2e3f4g5_split_moodlog_changes.py for SQLite safety
    op.add_column('task', sa.Column('estimated_minutes', sa.Integer(), nullable=True))
    # user-related changes moved to kl8m9n0o1p2_split_user_tables.py
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('userstats', sa.Column('current_level_xp', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('level', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('mood_logs_count', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('savings_goals_achieved', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('total_habit_days', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('average_mood_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('career_goals_completed', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('skills_learned', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('achievements_unlocked', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('habits_completed', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('learning_hours', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('total_xp', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('total_app_sessions', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('budgets_maintained', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('total_expenses_tracked', sa.INTEGER(), autoincrement=False, nullable=False))
    # use generic DateTime to be dialect-agnostic; SQLite will accept this
    op.add_column('userstats', sa.Column('last_activity', sa.DateTime(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('next_level_xp', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('userstats', sa.Column('wellness_streak', sa.INTEGER(), autoincrement=False, nullable=False))
    op.drop_column('userstats', 'monthly_reset_date')
    op.drop_column('userstats', 'weekly_reset_date')
    op.drop_column('userstats', 'monthly_points')
    op.drop_column('userstats', 'weekly_points')
    op.drop_column('userstats', 'last_activity_date')
    op.drop_column('userstats', 'days_active')
    op.drop_column('userstats', 'achievements_completed')
    op.drop_column('userstats', 'total_expenses_logged')
    op.drop_column('userstats', 'total_mood_logs')
    op.drop_column('userstats', 'total_tasks_completed')
    op.drop_column('userstats', 'total_habits_completed')
    op.drop_column('userstats', 'current_habit_streak')
    op.drop_column('userstats', 'points_to_next_level')
    op.drop_column('userstats', 'current_level')
    op.drop_column('userstats', 'total_points')
    op.add_column('usermemory', sa.Column('key', sa.VARCHAR(length=255), autoincrement=False, nullable=False))
    op.add_column('usermemory', sa.Column('expires_at', sa.DateTime(), autoincrement=False, nullable=True))
    op.add_column('usermemory', sa.Column('tags', sa.VARCHAR(length=500), autoincrement=False, nullable=True))
    op.add_column('usermemory', sa.Column('summary', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('usermemory', sa.Column('context', sa.VARCHAR(length=100), autoincrement=False, nullable=True))
    op.add_column('usermemory', sa.Column('value', sa.TEXT(), autoincrement=False, nullable=False))
    op.alter_column('usermemory', 'source',
               existing_type=sa.String(length=100),
               type_=sa.VARCHAR(length=50),
               nullable=False)
    op.drop_column('usermemory', 'related_entity_id')
    op.drop_column('usermemory', 'related_entity_type')
    op.drop_column('usermemory', 'category')
    op.drop_column('usermemory', 'content')
    op.add_column('userbadge', sa.Column('is_notified', sa.BOOLEAN(), autoincrement=False, nullable=False))
    op.add_column('userbadge', sa.Column('progress_value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.drop_column('userbadge', 'created_at')
    op.drop_column('userbadge', 'display_order')
    op.drop_column('userbadge', 'is_displayed')
    op.drop_column('userbadge', 'progress_snapshot')
    op.drop_column('userbadge', 'trigger_event')
    op.drop_column('userbadge', 'earned_date')
    op.drop_column('task', 'estimated_minutes')
    op.add_column('moodlog', sa.Column('goals_completed', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('moodlog', sa.Column('water_intake', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    op.add_column('moodlog', sa.Column('productivity_rating', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('moodlog', sa.Column('mood_label', sa.VARCHAR(length=50), autoincrement=False, nullable=True))
    op.add_column('moodlog', sa.Column('confidence_level', sa.INTEGER(), autoincrement=False, nullable=True))
    op.add_column('moodlog', sa.Column('motivation_level', sa.INTEGER(), autoincrement=False, nullable=True))
    op.alter_column('moodlog', 'is_private',
               existing_type=sa.BOOLEAN(),
               server_default=sa.text('true'),
               existing_nullable=False)
    op.alter_column('moodlog', 'entry_method',
               existing_type=sa.VARCHAR(length=20),
               server_default=sa.text("'manual'::character varying"),
               existing_nullable=False)
    op.alter_column('moodlog', 'triggers',
               existing_type=sa.JSON(),
               type_=sa.TEXT(),
               existing_nullable=True)
    op.alter_column('moodlog', 'activities',
               existing_type=sa.JSON(),
               type_=sa.TEXT(),
               existing_nullable=True)
    # embedding changes moved to gh6h7i8j9k0_split_embedding_changes.py
    # additional conversation fields moved to mn9o0p1q2r3_split_conversation_additional_fields.py
    op.drop_column('calendarevent', 'start_time')
    op.add_column('badge', sa.Column('points', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('badge', sa.Column('criteria', sa.TEXT(), autoincrement=False, nullable=True))
    op.add_column('badge', sa.Column('rarity', sa.VARCHAR(length=20), autoincrement=False, nullable=False))
    op.add_column('badge', sa.Column('is_hidden', sa.BOOLEAN(), autoincrement=False, nullable=False))
    op.drop_column('badge', 'is_secret')
    op.drop_column('badge', 'points_value')
    op.drop_column('badge', 'requirements')
    op.drop_column('badge', 'color')
    op.drop_column('badge', 'difficulty')
    op.drop_column('badge', 'badge_type')
    op.add_column('achievement', sa.Column('points_earned', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('achieved_at', sa.DateTime(), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('difficulty', sa.VARCHAR(length=20), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('rarity_score', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('title', sa.VARCHAR(length=255), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('user_id', sa.INTEGER(), autoincrement=False, nullable=False))
    op.add_column('achievement', sa.Column('value', sa.DOUBLE_PRECISION(precision=53), autoincrement=False, nullable=True))
    # create foreign key if it doesn't already exist
    try:
        bind = op.get_bind()
        inspector = sa.inspect(bind)
        ach_fks = [fk['name'] for fk in inspector.get_foreign_keys('achievement') if fk.get('name')]
    except Exception:
        ach_fks = []

    if 'achievement_user_id_fkey' not in ach_fks:
        op.create_foreign_key('achievement_user_id_fkey', 'achievement', 'user', ['user_id'], ['id'])

    try:
        bind = op.get_bind()
        inspector = sa.inspect(bind)
        ach_uniques = [uc['name'] for uc in inspector.get_unique_constraints('achievement') if uc.get('name')]
    except Exception:
        ach_uniques = []

    with op.batch_alter_table('achievement') as batch_op:
        # drop the named unique constraint in batch mode (SQLite-safe) only if present
        if 'uq_achievement_name' in ach_uniques:
            batch_op.drop_constraint('uq_achievement_name', type_='unique')
        batch_op.alter_column('description',
               existing_type=sa.TEXT(),
               nullable=True)
    op.drop_column('achievement', 'updated_at')
    op.drop_column('achievement', 'is_repeatable')
    op.drop_column('achievement', 'is_active')
    op.drop_column('achievement', 'difficulty_level')
    op.drop_column('achievement', 'icon_url')
    op.drop_column('achievement', 'points_reward')
    op.drop_column('achievement', 'measurement_unit')
    op.drop_column('achievement', 'target_value')
    op.drop_column('achievement', 'name')
    # ### end Alembic commands ###